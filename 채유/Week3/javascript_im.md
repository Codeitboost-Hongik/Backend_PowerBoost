# 자바스크립트 중급

속성: 토픽
교과목: Node.js 백엔드 개발 기초
기한: 2024년 5월 28일
상태: 진행 중

# 🍀 JavaScript 중급

## 1 장 | 인터랙티브 자바스크립트

---

### 1절. 인터랙티브 자바스크립트 시작하기

| 메소드 | 의미 | 결과 |
| --- | --- | --- |
| document.getElementById('id') | HTML id속성으로 태그 선택하기 | id에 해당하는 태그 하나 |
| document.getElementsByClassName('class') | HTML class속성으로 태그 선택하기 | class에 해당하는 태그 모음(HTMLCollection) |
| document.getElementsByTagName('tag') | HTML 태그 이름으로 태그 선택하기 | tag에 해당하는 태그 모음(HTMLCollection) |
| document.querySelector('css') | css 선택자로 태그 선택하기 | css 선택자에 해당하는 태그 중 가장 첫번째 태그 하나 |
| document.querySelectorAll('css') | css 선택자로 태그 선택하기 | css 선택자에 해당하는 태그 모음(NodeList) |
- **id로 태그 선택하기**
    
    `const myTag = document.getElementById('id');`
    
    - id : 다른 태그들과 구분하기 위해 붙여주는 고유한 값
    - getElementById : document 객체의 메소드
    - 'id'에 존재하지 않는 id가 들어갈 경우 `null` 리턴
    
- **class로 태그 선택하기**
    
    `const myTags = document.getElementsByClassName('id');`
    
    - 유사배열(array-like object) HTMLCollection 리턴
        - 숫자 형태의 indexing 가능(0부터 시작)
        - length 프로퍼티가 있음
        - 배열의 기본 메소드(splice, push) 사용 불가능
        - Array.isArray(유사배열)은 false다.
    - 유사 배열에서 태그의 순서는 깊이와 상관없이 위에서 차례대로!
    - 배열에 원소(태그)가 1개라면 그 태그가 선택되는 것이 아니라, 0번 인덱스로 접근해줘야 함
    - 'class'에 존재하지 않는 class가 들어갈 경우 `HTMLCollection []`  리턴

- **TagName으로 태그 선택하기**
    
    `const myTags = document.getElementsByTagName('tagName');`
    
    - HTMLCollection 리턴
    - ‘*’ 으로 모든 태그 선택

- **css 선택자로 태그 선택하기**
    
    `const myTag = document.querySelector('css');`
    
    - css 선택자 : ‘#ID
    - class 선택자 : ‘.CLASSNAME’
        - 클래스에 있는 태그들 중 가장 위에 있는 **하나**만 선택
    
    `const myTags = document.querySelectorAll('css');`
    
    - 유사배열(NodeList) 리턴
    - 만약 존재하지 않는 요소를 선택할 경우, NodeList[] 리
    

<aside>
💡 `console.log(document.querySelector('#list li'));`

- id가 list인 요소들 중 li 태그를 사용하는 태그
</aside>

- **이벤트와 버튼 클릭**
    - 이벤트 : 웹 페이지에서 발생하는 대부분의 일(사건)들
        
        ex) 버튼 클릭, 스크롤, 키보드 입력
        
    - 이벤트 핸들링(Event Handling)
        
        : 이벤트가 발생했을 때 어떤 특별한 동작을 하도록 함
        
    - 이벤트 핸들러(Event Handler)
        
        : 동작을 구체적인 코드로 작성한 함수 부분, 이벤트 리스너(Event Listener)라고도 함
        
        ```jsx
        //JS에 작성
        const btn = document.querySelector('#myBtn');
        btn.onclick = function() {
        console.log('Hello Codeit!');
        };
        
        //HTML에 작
        <button id="myBtn" onclick="console.log('Hello Codeit!')">클릭!</button>
        ```
        
    - HTML : 웹페이지 구조 결정
        
        JS : 동작 담당
        
        - js코드를 html에 같이 작성할 수 있지만 권장X

### 2절. 브라우저와 자바스크립트

- **window 객체**
    - [전역 객체(Global Object)](https://developer.mozilla.org/ko/docs/Web/API/Window)
    - window 객체의 property 응용
        
        ```jsx
        //window 객체는 window.을 붙이지 않아도 됨 
        window.console.log(window.innerWidth); 
        window.document.querySelector('css')
        
        console.log(window.innerWidth); //윈도우 창 넓이
        console.log(window.innerWidth); //윈도우 창 높이
        
        window.open() //새 윈도우 창 열기
        window.close() //현재 윈도우 창 닫기
        ```
        
- **DOM(Document Object Model)**
    - 문서 객체 모델; **HTML 문서 전체를 객체로 표현**한 것
        - document의 타입은 object이지만 직접적으로 접근하게 된다면 HTML이 출력됨
        - console.dir(document) : document 객체의 property 출력
            - 문자열로 콘솔에 출력
            - 객체의 속성 출력
            - 여러 값을 전달하더라도 첫 번째 값만 출력
            - log 메소드는 대상을 HTML 형태로 출력하고, 객체의 속성에 좀 더 중점을 둔 dir 메소드는 대상을 객체 형태로 출력
            
    - DOM을 사용하여 JS로 HTML 태그를 객체처럼 다룰 수 있다
    
- **DOM 트리**
    - 요소노드(tag)와 텍스트 노드(txt)
        
        ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20708f942b41ea44a1a2222901d051ed16/Untitled.png)
        
    - 노드 접근하기
        - 요소노드 접근하기
            
            ```jsx
            const myTag = document.querySelector('#content');
            
            //자식 요소 노드 
            console.log(myTag.children); //자식 노드 태그들을 담은 유사배열 리턴
            console.log(myTag.firstElementChild); //첫번째 자식 노드 선택
            console.log(myTag.lastElementChild); //마지막 자식 노드 선택
            
            //부모 요소 노드 
            console.log(myTag.parentElement); //body tag 선택
            
            //형제 요소 노드
            console.log(myTag.previousElementSibiling); //없다면 null 출
            console.log(myTag.nextElementSibiling); 
            
            console.log(myTag.parentElement.nextElementSibiling); //부모노드의 다음 형제노드 선택
            ```
            
        - 텍스트노드 접근하기
            
            
            | 프로퍼티 | 유형 | 결과 |
            | --- | --- | --- |
            | node.childNodes | 자식 노드 | node의 자식 노드 모음(NodeList) |
            | node.firstChild | 자식 노드 | node의 첫 번째 자식 노드 하나 |
            | node.lastChild | 자식 노드 | node의 마지막 자식 노드 하나 |
            | node.parentNode | 부모 노드 | node의 부모 요소 하나 |
            | node.previousSibling | 형제 노드 | node의 이전(previous) 혹은 좌측(left)에 있는 노드 하나 |
            | node.nextSibling | 형제 노드 | node의 다음(next) 혹은 우측(right)에 있는 노드 하나 |
            
    - 요소노드 프로퍼티
        - innerHTML
            - `console.log(myTag.innerHTML);`
                - 요소 노드 내부의 HTML 코드를 문자열로 리턴
                - 줄 바꿈이나 들여쓰기 모두 포함
            - `myTag.innerHTML = '<li>새로운텍스트</li>';`
                - HTML 자체를 수정할 수 있음 → 내부에 있던 값을 완전히 새로운 값으로 교체
        - outerHTML
            - `console.log(myTag.outerHTML);`
                - 요소 노드 자체의 전체적인 HTML 코드를 문자열로 리턴
                - 내부에 있는 줄 바꿈이나 들여쓰기 모두 포함
                
            - `myTag.outerHTML = '<ul id="new-list"><li>새로운텍스트</li></ul>';`
                - HTML 자체를 수정할 수 있음 → 요소 자체가 교체
        - textContent
            - `console.log(myTag.textContent);`
                - 요소 안의 내용들 중에서 HTML 태그 부분은 제외하고 텍스트만 가져옴
                - 내부에 있는 줄 바꿈이나 들여쓰기 모두 포함
            - `myTag.textContent = '<li>새로운텍스트!</li>';`
                - 내부의 값을 새로운 값으로 교체 → 특수문자도 그냥 텍스트로 처리
        
    - 요소노드 추가하기
        - 페이지가 동적으로 변할 수 있게 조작하기 위해서
        
        - 요소 노드 만들기
            
            `const first = document.createElement('태그이름')`
            
        - 요소 노드 꾸미기
            
            `first.textContent = '처음'`
            
        - 요소노드 추가하기
            - append - 대상을 node 의 마지막에 삽입
            - prepend - 대상을 node 의 가장 앞에 삽입
            - before - 대상을 node 이전에 삽입
            - after - 대상을 node 다음에 삽입
    - 노드 삭제와 이동하기
        - 노드 삭제
            
            `Node.remove()`
            
        - 노드 이동(append, prepend, before, after)
            
            `today.append(tommorrow.children[1]);` 
            
            내일 할 일의 2번째 요소를 오늘 할 일에 추가하기
            
        
    
- **HTML 속성 다루기**
    - HTML의 속성과 dom의 property
        - 일반적으로 HTML attribute 사용하여 초기 값을 설정하고 DOM property를 사용하여 요소의 상태를 동적으로 조작한다.
        - HTML에서의 속성은 attribute
            - element가 가지고 있는 것, 정적
            - `name="value"` 의 형태
            
            ex) `<input value="codeit" />` // attribute : `value="codeit"`
            
        
        - Dom에서의 속성은 property
            - HTML Dom 트리 안에 존재하고 JavaScript에 의해 생성되고 조작되는 값, 동적
            - ex) `<input />`에 “Hi World!” 입력하면 “Hi World!”는 다른 값으로 대체 가능하고 변하기 때문에 property가 됨
        
    - HTML의 속성 $\nrightarrow$ 요소노드(DOM)의 프로퍼티
        
        ex) href : HTML 표준X
        
    
    - 속성에 접근하기 `elem.getAttribute('속성')`
        - class 속성
            
            ```jsx
            //property 이름으로 접근
            console.log(item.className);
            
            //속성으로 접근
            elem.getAttribute('class')
            ```
            
        
    - 속성 추가(수정)하기 `elem.setAttribute('속성','값')`
    - 속성 제거하기 `elem.removeAttribute('속성')`
    - 3개의 메소드 모두 대소문자 상관X
        
        ex) `elem.removeAttribute('HRef')` == `elem.removeAttribute('href')`
        
- **스타일 다루기**
    - style 프로퍼티를 이용하기 보다는 클래스로 다루는 것이 좋다
    - elem.classList: add, remove, toggle
    
    ```jsx
    // 요소 하나하나에 스타일 적용 -> 귀찮음
    object.children[0].style.textDecoration = 'line-through';
    object.children[3].style.textDecoration = 'line-through';
    
    // class를 적용시키기 -> 원래 있던 클래스가 사라짐
    object.children[1].className = 'done'
    
    // elem.classList: add, remove, toggle
    object.classList.add('done', 'other'); //done과 다른 클래스 추가
    object.classList.remove('done', 'other'); //done과 다른 클래스 삭제
    object.classList.toggle('done'); //done이 없으면 추가, 있으면 삭제
    object.classList.toggle('done', 'BOOLEAN'); //BOOLEAN이 true이면 추가, false이면 삭제
    ```
    
- 😦 비표준 속성 다루기 😦
    
    [비표준 속성 다루기 - 인터랙티브 자바스크립트 | 코드잇](https://www.codeit.kr/topics/interactive-javascript/lessons/3829)
    

### 3절. 이벤트 살펴보기

### 4절. 다양한 이벤트 알아보기

## 2 장 |  모던 자바스크립트

---

### 1절. 정리한 내용

1. **모델링**: 현실세계를 추상화(모형화), 단순화, 명확화하기 위해 일정한 표기법에 의해 표현하는 기법
    - 모델링에 대한 다양한 정의
        - 웹스터 사전
            - 가설적 또는 일정 양식에 맞춘 표현 (a hypothetical or stylized representation)
            - 어떤 것에 대한 예비표현으로 그로부터 최종 대상이 구축되도록 하는 계획으로서 기여하는 것
        - 복잡한 '현실세계'를 단순화해 표현하는 것이다.
        - 모델이란 사물 또는 사건에 관한 양상(Aspect)이나 관점(Perspective)을 연관된 사람이나 그룹을 위하여 명확하게 하는 것이다.
        - 모델이란 현실세계를 추상화한 반영이다.
    - 특징
        - 추상화(모형화): 현실세계를 일정한 형식에 맞춰 표현함
        - 단순화: 복잡한 현실세계를 제한된 표기법이나 언어로 쉽게 표현함
        - 명확화: 이해가 쉽게 표현함
        
        <aside>
        💯 구체화, 복잡화, 일반화 X
        
        </aside>
        
    - 모델링의 세가지 관점
        - 데이터 관점(What, Data): 업무와 데이터 및 데이터 사이의 관계를 모델링
        - 프로세스 관점(How, Process): 업무가 실제로 하는 일을 모델링
        - 데이터와 프로세스의 상관 관점(Data vs Process, Interaction): 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향받고 있는지 모델링
        
2. **데이터 모델링**
- 데이터 모델링이란?
    - 정보시스템 구축을 위한 데이터 관점의 업무 분석 기법
    - 현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정
    - 데이터베이스를 구축하기 위한 분석/설계의 과정
    
- 데이터 모델링의 기능
    - 가시화
    - 명세화
    - 구조화된 틀 제공
    - 문서화
    - 다양한 관점 제공
    - 구체화
    
1. **데이터 모델링의 중요성과 유의점**
    - 데이터 모델링의 중요성
        - 파급효과(Leverage)
        - 간결한 표현(Conciseness): 설계 도면; 데이터 정합성을 유지
            - 데이터 정합성 : 어떤 데이터들이 값이 서로 일치함. 중복 데이터를 많이 사용하면 데이터끼리 정합성을 맞추기 어렵다. 비정규형을 사용해 아노말리(Anomaly : 이상현상)가 발생하면 정합성이 깨진다. 정합성은 데이터가 서로 모순 없이 일관되게 일치해야 함을 의미함
        - 데이터 품질
    
    - 데이터 모델링의 유의점
        - 중복 : 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.
        - 비유연성 : 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 가능성을 줄인다.
        - 비일관성 : 데이터의 중복이 없더라도 비일관성(Inconsistency)은 발생한다. 데이터 모델링을 할때, 데이터와 데이터 간 상호 연관관계에 대한 명확한 정의는 이러한 위험을 예방할 수 있도록 해준다. (예) 개발자가 다른 데이터와 모순된다는 고려 없이 데이터를 수정할 가능성이 있음
        
2.  **데이터  모델링의 3단계**
    - 개념적 모델링: 추상화 수준 ⬆️ 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA 수립, ERD 작성
    - 논리적 모델링: 식별자(key)를 도출하고 속성과 관계 등을 정의함, 정규화를 수행하여 데이터 모델의 독립성과 재사용성 확보, 논리 데이터 모델은 데이터 모델링 완료 상태
    - 물리적 모델링: 실제 DB를 구축할 수 있도록 성능 및 보안 등 물리적인 성격 고려
    
3. **프로젝트 생명주기에서 데이터 모델링**

프로젝트 생명주기(Life Cycle): 계획 > 분석 > 설계 > 개발 > 테스트 > 전환/이행 단계로 구성

1) 계획과 분석 단계 - 개념적 모델링 

2) 분석 단계 - 논리적 모델링 

3) 설계 단계 - 물리적 모델링에 해당

단 현실 프로젝트에서는 개념적 데이터 모델이 생략된 개념/논리 데이터 모델링이 분석 단계 때 대부분 수행된다.

1. **데이터 모델링에서 데이터 독립성의 이해**
- 데이터 독립성의 필요성
    - 데이터 중복성 증가
    - 데이터 복잡도 증가
    
    에 의한
    
    - 유지보수 비용 증가
    - 요구사항 대응 저하
    
    => 데이터 독립성이 필요
    

- 데이터 독립성을 확보하면 다음과 같은 효과를 얻을 수 있다.
    - 각 뷰(View)의 독립성을 유지하고 계층별 뷰에 영향을 주지 않고 변경할 수 있다.
    - 단계별 스키마(Schema)에 따라 데이터 정의어 (DDL) 와 데이터 조작어 (DML)가 다름을 제공한다.

- 데이터베이스 3단계 구조 : 데이터 독립성 확보를 목표로 함
    
    ANSI/SPARC의 3단계 구성의 데이터 독립성 모델은 외부단계와 개념적 단계, 내부적 단계로 구성된 서로 간섭되지 않는 모델을 제시하고 있다.
    
    - 외부스키마 (External Schema) : View 단계의 여러 사용자 관점으로 구성. 개인적. DB개인사용자나 응용프로그래머가 접근
    - 개념스키마 (Conceptual Schema) : 모든 관점 통합. 조직 전체 관점. 조직 전체 DB 기술, 설계자 관점 데이터 모델링의 지향점, DB의 각 사용자나 응용프로그래머가 접근하는 DB의 정의
    - 내부스키마 (Internal Schema) : 내부단계 구성. DB가 물리적으로 저장된 형식. 실제로 저장된 방법 표현, 개발자 관점

- 두 영역의 데이터 독립성
    
    이렇게 3단계로 개념이 분리되면서 각각의 영역에 대한 독립성을 지정하는 용어가 바로 논리적인 독립성과 물리적인 독립성이다.
    
    - 논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것. 논리적 구조가 변경되어도 응용 프로그램에 영향 없음
    - 물리적 독립성 : 내부 스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않도록 지원하는 것. 저장장치의 구조변경은 응용프로그램과 개념스키마에 영향 없음
    
    ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20708f942b41ea44a1a2222901d051ed16/Untitled%201.png)
    

- 사상(Mapping)
    - 외부적/개념적 사상 (논리적 사상) : 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함
    - 개념적/내부적 사상 (물리적 사상) : 개념적 뷰와 저장된 데이터베이스의 상호 관련성을 정의함.

1. **데이터 모델링의 중요한 세 가지 개념**
- 데이터 모델링의 세 가지 요소
    
    1) 업무가 관여하는 어떤 것(Things) - 엔터티
    
    2) 어떤 것이 가지는 성격 (Attributes) - 속성
    
    3) 업무가 관여하는 어떤 것 간의 관계 (Relationships) - 관계
    
- 단수와 집합(복수)의 명명
    
    ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20708f942b41ea44a1a2222901d051ed16/Untitled%202.png)
    

1. **데이터 모델의 표기법인 ERD 이해**
- 데이터 모델 표기법
    - 1976년 피터첸(Peter Chen)에 의해 E-R Model (Entity-Relationship Model) 표기법이 만들어짐.
    - 서로 다른 뷰를 충족시킬 수 있는 데이터 처리와 계약 조건 등의 요구사항을 정의하기 위함
    - 개체-관계 모델은 개체-관계 다이어그램(ERD)로 표현
    - ERD는 최종 사용자의 관점에서 데이터 구조를 그림 형태로 묘사하기 위해 개체, 관계, 속성 이라는 세 개의 기본요소를 사용하며, 엔터티와 이들간의 관계를 미리 약속된 도형을 사용하여 알기 쉽게 그림으로 표시한 것.
    - 엔터티는 사각형 관계는 마름모 속성은 타원형으로 표현, 현실의 데이터 모두 표현 가능
    
- ERD 작업순서
    
    1. 엔터티를 도출, 그린다
    
    2. 엔터티를 적절하게 배치
    
    3. 엔터티간 관계 설정
    
    4. 관계명 기술
    
    5. 관계차수 표현: 1:1, 1:N, M:N
    
    6. 관계선택사양 표현: 필수, 선택
    

1. **좋은 데이터 모델의 요소**
- 완전성 : 업무에서 필요로하는 모든 데이터가 데이터 모델에 정의되어 있어야 한다.
- 중복 배제 : 하나의 데이터베이스 내에 동일한 사실은 반드시 한 번만 기록하여야 한다.
- 업무 규칙 : 데이터 모델에 업무규칙을 나타내야 한다.
- 데이터 재사용 : 데이터의 통합성과 독립성에 대해 충분히 고려하여 재사용성을 향상시켜야 한다.
- 의사소통 : 데이터 모델이 의사소통의 도구로서의 역할을 해야 한다.
- 통합성 : 공유 데이터에 대한 구조를 여러 업무 영역에서 공동으로 사용하기 용이하게 설계할 수 있어야 한다.

## 3 장 |  자바스크립트 객체 지기

---

### 1절. 정리한 내용

1. **모델링**: 현실세계를 추상화(모형화), 단순화, 명확화하기 위해 일정한 표기법에 의해 표현하는 기법
    - 모델링에 대한 다양한 정의
        - 웹스터 사전
            - 가설적 또는 일정 양식에 맞춘 표현 (a hypothetical or stylized representation)
            - 어떤 것에 대한 예비표현으로 그로부터 최종 대상이 구축되도록 하는 계획으로서 기여하는 것
        - 복잡한 '현실세계'를 단순화해 표현하는 것이다.
        - 모델이란 사물 또는 사건에 관한 양상(Aspect)이나 관점(Perspective)을 연관된 사람이나 그룹을 위하여 명확하게 하는 것이다.
        - 모델이란 현실세계를 추상화한 반영이다.
    - 특징
        - 추상화(모형화): 현실세계를 일정한 형식에 맞춰 표현함
        - 단순화: 복잡한 현실세계를 제한된 표기법이나 언어로 쉽게 표현함
        - 명확화: 이해가 쉽게 표현함
        
        <aside>
        💯 구체화, 복잡화, 일반화 X
        
        </aside>
        
    - 모델링의 세가지 관점
        - 데이터 관점(What, Data): 업무와 데이터 및 데이터 사이의 관계를 모델링
        - 프로세스 관점(How, Process): 업무가 실제로 하는 일을 모델링
        - 데이터와 프로세스의 상관 관점(Data vs Process, Interaction): 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향받고 있는지 모델링
        
2. **데이터 모델링**
- 데이터 모델링이란?
    - 정보시스템 구축을 위한 데이터 관점의 업무 분석 기법
    - 현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정
    - 데이터베이스를 구축하기 위한 분석/설계의 과정
    
- 데이터 모델링의 기능
    - 가시화
    - 명세화
    - 구조화된 틀 제공
    - 문서화
    - 다양한 관점 제공
    - 구체화
    
1. **데이터 모델링의 중요성과 유의점**
    - 데이터 모델링의 중요성
        - 파급효과(Leverage)
        - 간결한 표현(Conciseness): 설계 도면; 데이터 정합성을 유지
            - 데이터 정합성 : 어떤 데이터들이 값이 서로 일치함. 중복 데이터를 많이 사용하면 데이터끼리 정합성을 맞추기 어렵다. 비정규형을 사용해 아노말리(Anomaly : 이상현상)가 발생하면 정합성이 깨진다. 정합성은 데이터가 서로 모순 없이 일관되게 일치해야 함을 의미함
        - 데이터 품질
    
    - 데이터 모델링의 유의점
        - 중복 : 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.
        - 비유연성 : 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 가능성을 줄인다.
        - 비일관성 : 데이터의 중복이 없더라도 비일관성(Inconsistency)은 발생한다. 데이터 모델링을 할때, 데이터와 데이터 간 상호 연관관계에 대한 명확한 정의는 이러한 위험을 예방할 수 있도록 해준다. (예) 개발자가 다른 데이터와 모순된다는 고려 없이 데이터를 수정할 가능성이 있음
        
2.  **데이터  모델링의 3단계**
    - 개념적 모델링: 추상화 수준 ⬆️ 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA 수립, ERD 작성
    - 논리적 모델링: 식별자(key)를 도출하고 속성과 관계 등을 정의함, 정규화를 수행하여 데이터 모델의 독립성과 재사용성 확보, 논리 데이터 모델은 데이터 모델링 완료 상태
    - 물리적 모델링: 실제 DB를 구축할 수 있도록 성능 및 보안 등 물리적인 성격 고려
    
3. **프로젝트 생명주기에서 데이터 모델링**

프로젝트 생명주기(Life Cycle): 계획 > 분석 > 설계 > 개발 > 테스트 > 전환/이행 단계로 구성

1) 계획과 분석 단계 - 개념적 모델링 

2) 분석 단계 - 논리적 모델링 

3) 설계 단계 - 물리적 모델링에 해당

단 현실 프로젝트에서는 개념적 데이터 모델이 생략된 개념/논리 데이터 모델링이 분석 단계 때 대부분 수행된다.

1. **데이터 모델링에서 데이터 독립성의 이해**
- 데이터 독립성의 필요성
    - 데이터 중복성 증가
    - 데이터 복잡도 증가
    
    에 의한
    
    - 유지보수 비용 증가
    - 요구사항 대응 저하
    
    => 데이터 독립성이 필요
    

- 데이터 독립성을 확보하면 다음과 같은 효과를 얻을 수 있다.
    - 각 뷰(View)의 독립성을 유지하고 계층별 뷰에 영향을 주지 않고 변경할 수 있다.
    - 단계별 스키마(Schema)에 따라 데이터 정의어 (DDL) 와 데이터 조작어 (DML)가 다름을 제공한다.

- 데이터베이스 3단계 구조 : 데이터 독립성 확보를 목표로 함
    
    ANSI/SPARC의 3단계 구성의 데이터 독립성 모델은 외부단계와 개념적 단계, 내부적 단계로 구성된 서로 간섭되지 않는 모델을 제시하고 있다.
    
    - 외부스키마 (External Schema) : View 단계의 여러 사용자 관점으로 구성. 개인적. DB개인사용자나 응용프로그래머가 접근
    - 개념스키마 (Conceptual Schema) : 모든 관점 통합. 조직 전체 관점. 조직 전체 DB 기술, 설계자 관점 데이터 모델링의 지향점, DB의 각 사용자나 응용프로그래머가 접근하는 DB의 정의
    - 내부스키마 (Internal Schema) : 내부단계 구성. DB가 물리적으로 저장된 형식. 실제로 저장된 방법 표현, 개발자 관점

- 두 영역의 데이터 독립성
    
    이렇게 3단계로 개념이 분리되면서 각각의 영역에 대한 독립성을 지정하는 용어가 바로 논리적인 독립성과 물리적인 독립성이다.
    
    - 논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것. 논리적 구조가 변경되어도 응용 프로그램에 영향 없음
    - 물리적 독립성 : 내부 스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않도록 지원하는 것. 저장장치의 구조변경은 응용프로그램과 개념스키마에 영향 없음
    
    ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20708f942b41ea44a1a2222901d051ed16/Untitled%201.png)
    

- 사상(Mapping)
    - 외부적/개념적 사상 (논리적 사상) : 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함
    - 개념적/내부적 사상 (물리적 사상) : 개념적 뷰와 저장된 데이터베이스의 상호 관련성을 정의함.

1. **데이터 모델링의 중요한 세 가지 개념**
- 데이터 모델링의 세 가지 요소
    
    1) 업무가 관여하는 어떤 것(Things) - 엔터티
    
    2) 어떤 것이 가지는 성격 (Attributes) - 속성
    
    3) 업무가 관여하는 어떤 것 간의 관계 (Relationships) - 관계
    
- 단수와 집합(복수)의 명명
    
    ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20708f942b41ea44a1a2222901d051ed16/Untitled%202.png)
    

1. **데이터 모델의 표기법인 ERD 이해**
- 데이터 모델 표기법
    - 1976년 피터첸(Peter Chen)에 의해 E-R Model (Entity-Relationship Model) 표기법이 만들어짐.
    - 서로 다른 뷰를 충족시킬 수 있는 데이터 처리와 계약 조건 등의 요구사항을 정의하기 위함
    - 개체-관계 모델은 개체-관계 다이어그램(ERD)로 표현
    - ERD는 최종 사용자의 관점에서 데이터 구조를 그림 형태로 묘사하기 위해 개체, 관계, 속성 이라는 세 개의 기본요소를 사용하며, 엔터티와 이들간의 관계를 미리 약속된 도형을 사용하여 알기 쉽게 그림으로 표시한 것.
    - 엔터티는 사각형 관계는 마름모 속성은 타원형으로 표현, 현실의 데이터 모두 표현 가능
    
- ERD 작업순서
    
    1. 엔터티를 도출, 그린다
    
    2. 엔터티를 적절하게 배치
    
    3. 엔터티간 관계 설정
    
    4. 관계명 기술
    
    5. 관계차수 표현: 1:1, 1:N, M:N
    
    6. 관계선택사양 표현: 필수, 선택
    

1. **좋은 데이터 모델의 요소**
- 완전성 : 업무에서 필요로하는 모든 데이터가 데이터 모델에 정의되어 있어야 한다.
- 중복 배제 : 하나의 데이터베이스 내에 동일한 사실은 반드시 한 번만 기록하여야 한다.
- 업무 규칙 : 데이터 모델에 업무규칙을 나타내야 한다.
- 데이터 재사용 : 데이터의 통합성과 독립성에 대해 충분히 고려하여 재사용성을 향상시켜야 한다.
- 의사소통 : 데이터 모델이 의사소통의 도구로서의 역할을 해야 한다.
- 통합성 : 공유 데이터에 대한 구조를 여러 업무 영역에서 공동으로 사용하기 용이하게 설계할 수 있어야 한다.

## 4 장 |  자바스크립트 웹 개발 기본기

---

### 1절. 정리한 내용

1. **모델링**: 현실세계를 추상화(모형화), 단순화, 명확화하기 위해 일정한 표기법에 의해 표현하는 기법
    - 모델링에 대한 다양한 정의
        - 웹스터 사전
            - 가설적 또는 일정 양식에 맞춘 표현 (a hypothetical or stylized representation)
            - 어떤 것에 대한 예비표현으로 그로부터 최종 대상이 구축되도록 하는 계획으로서 기여하는 것
        - 복잡한 '현실세계'를 단순화해 표현하는 것이다.
        - 모델이란 사물 또는 사건에 관한 양상(Aspect)이나 관점(Perspective)을 연관된 사람이나 그룹을 위하여 명확하게 하는 것이다.
        - 모델이란 현실세계를 추상화한 반영이다.
    - 특징
        - 추상화(모형화): 현실세계를 일정한 형식에 맞춰 표현함
        - 단순화: 복잡한 현실세계를 제한된 표기법이나 언어로 쉽게 표현함
        - 명확화: 이해가 쉽게 표현함
        
        <aside>
        💯 구체화, 복잡화, 일반화 X
        
        </aside>
        
    - 모델링의 세가지 관점
        - 데이터 관점(What, Data): 업무와 데이터 및 데이터 사이의 관계를 모델링
        - 프로세스 관점(How, Process): 업무가 실제로 하는 일을 모델링
        - 데이터와 프로세스의 상관 관점(Data vs Process, Interaction): 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향받고 있는지 모델링
        
2. **데이터 모델링**
- 데이터 모델링이란?
    - 정보시스템 구축을 위한 데이터 관점의 업무 분석 기법
    - 현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정
    - 데이터베이스를 구축하기 위한 분석/설계의 과정
    
- 데이터 모델링의 기능
    - 가시화
    - 명세화
    - 구조화된 틀 제공
    - 문서화
    - 다양한 관점 제공
    - 구체화
    
1. **데이터 모델링의 중요성과 유의점**
    - 데이터 모델링의 중요성
        - 파급효과(Leverage)
        - 간결한 표현(Conciseness): 설계 도면; 데이터 정합성을 유지
            - 데이터 정합성 : 어떤 데이터들이 값이 서로 일치함. 중복 데이터를 많이 사용하면 데이터끼리 정합성을 맞추기 어렵다. 비정규형을 사용해 아노말리(Anomaly : 이상현상)가 발생하면 정합성이 깨진다. 정합성은 데이터가 서로 모순 없이 일관되게 일치해야 함을 의미함
        - 데이터 품질
    
    - 데이터 모델링의 유의점
        - 중복 : 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.
        - 비유연성 : 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 가능성을 줄인다.
        - 비일관성 : 데이터의 중복이 없더라도 비일관성(Inconsistency)은 발생한다. 데이터 모델링을 할때, 데이터와 데이터 간 상호 연관관계에 대한 명확한 정의는 이러한 위험을 예방할 수 있도록 해준다. (예) 개발자가 다른 데이터와 모순된다는 고려 없이 데이터를 수정할 가능성이 있음
        
2.  **데이터  모델링의 3단계**
    - 개념적 모델링: 추상화 수준 ⬆️ 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA 수립, ERD 작성
    - 논리적 모델링: 식별자(key)를 도출하고 속성과 관계 등을 정의함, 정규화를 수행하여 데이터 모델의 독립성과 재사용성 확보, 논리 데이터 모델은 데이터 모델링 완료 상태
    - 물리적 모델링: 실제 DB를 구축할 수 있도록 성능 및 보안 등 물리적인 성격 고려
    
3. **프로젝트 생명주기에서 데이터 모델링**

프로젝트 생명주기(Life Cycle): 계획 > 분석 > 설계 > 개발 > 테스트 > 전환/이행 단계로 구성

1) 계획과 분석 단계 - 개념적 모델링 

2) 분석 단계 - 논리적 모델링 

3) 설계 단계 - 물리적 모델링에 해당

단 현실 프로젝트에서는 개념적 데이터 모델이 생략된 개념/논리 데이터 모델링이 분석 단계 때 대부분 수행된다.

1. **데이터 모델링에서 데이터 독립성의 이해**
- 데이터 독립성의 필요성
    - 데이터 중복성 증가
    - 데이터 복잡도 증가
    
    에 의한
    
    - 유지보수 비용 증가
    - 요구사항 대응 저하
    
    => 데이터 독립성이 필요
    

- 데이터 독립성을 확보하면 다음과 같은 효과를 얻을 수 있다.
    - 각 뷰(View)의 독립성을 유지하고 계층별 뷰에 영향을 주지 않고 변경할 수 있다.
    - 단계별 스키마(Schema)에 따라 데이터 정의어 (DDL) 와 데이터 조작어 (DML)가 다름을 제공한다.

- 데이터베이스 3단계 구조 : 데이터 독립성 확보를 목표로 함
    
    ANSI/SPARC의 3단계 구성의 데이터 독립성 모델은 외부단계와 개념적 단계, 내부적 단계로 구성된 서로 간섭되지 않는 모델을 제시하고 있다.
    
    - 외부스키마 (External Schema) : View 단계의 여러 사용자 관점으로 구성. 개인적. DB개인사용자나 응용프로그래머가 접근
    - 개념스키마 (Conceptual Schema) : 모든 관점 통합. 조직 전체 관점. 조직 전체 DB 기술, 설계자 관점 데이터 모델링의 지향점, DB의 각 사용자나 응용프로그래머가 접근하는 DB의 정의
    - 내부스키마 (Internal Schema) : 내부단계 구성. DB가 물리적으로 저장된 형식. 실제로 저장된 방법 표현, 개발자 관점

- 두 영역의 데이터 독립성
    
    이렇게 3단계로 개념이 분리되면서 각각의 영역에 대한 독립성을 지정하는 용어가 바로 논리적인 독립성과 물리적인 독립성이다.
    
    - 논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것. 논리적 구조가 변경되어도 응용 프로그램에 영향 없음
    - 물리적 독립성 : 내부 스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않도록 지원하는 것. 저장장치의 구조변경은 응용프로그램과 개념스키마에 영향 없음
    
    ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20708f942b41ea44a1a2222901d051ed16/Untitled%201.png)
    

- 사상(Mapping)
    - 외부적/개념적 사상 (논리적 사상) : 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함
    - 개념적/내부적 사상 (물리적 사상) : 개념적 뷰와 저장된 데이터베이스의 상호 관련성을 정의함.

1. **데이터 모델링의 중요한 세 가지 개념**
- 데이터 모델링의 세 가지 요소
    
    1) 업무가 관여하는 어떤 것(Things) - 엔터티
    
    2) 어떤 것이 가지는 성격 (Attributes) - 속성
    
    3) 업무가 관여하는 어떤 것 간의 관계 (Relationships) - 관계
    
- 단수와 집합(복수)의 명명
    
    ![Untitled](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20708f942b41ea44a1a2222901d051ed16/Untitled%202.png)
    

1. **데이터 모델의 표기법인 ERD 이해**
- 데이터 모델 표기법
    - 1976년 피터첸(Peter Chen)에 의해 E-R Model (Entity-Relationship Model) 표기법이 만들어짐.
    - 서로 다른 뷰를 충족시킬 수 있는 데이터 처리와 계약 조건 등의 요구사항을 정의하기 위함
    - 개체-관계 모델은 개체-관계 다이어그램(ERD)로 표현
    - ERD는 최종 사용자의 관점에서 데이터 구조를 그림 형태로 묘사하기 위해 개체, 관계, 속성 이라는 세 개의 기본요소를 사용하며, 엔터티와 이들간의 관계를 미리 약속된 도형을 사용하여 알기 쉽게 그림으로 표시한 것.
    - 엔터티는 사각형 관계는 마름모 속성은 타원형으로 표현, 현실의 데이터 모두 표현 가능
    
- ERD 작업순서
    
    1. 엔터티를 도출, 그린다
    
    2. 엔터티를 적절하게 배치
    
    3. 엔터티간 관계 설정
    
    4. 관계명 기술
    
    5. 관계차수 표현: 1:1, 1:N, M:N
    
    6. 관계선택사양 표현: 필수, 선택
    

1. **좋은 데이터 모델의 요소**
- 완전성 : 업무에서 필요로하는 모든 데이터가 데이터 모델에 정의되어 있어야 한다.
- 중복 배제 : 하나의 데이터베이스 내에 동일한 사실은 반드시 한 번만 기록하여야 한다.
- 업무 규칙 : 데이터 모델에 업무규칙을 나타내야 한다.
- 데이터 재사용 : 데이터의 통합성과 독립성에 대해 충분히 고려하여 재사용성을 향상시켜야 한다.
- 의사소통 : 데이터 모델이 의사소통의 도구로서의 역할을 해야 한다.
- 통합성 : 공유 데이터에 대한 구조를 여러 업무 영역에서 공동으로 사용하기 용이하게 설계할 수 있어야 한다.

# 🍀 스터디 진행

## 📚 강의 리뷰(질문 및 정보 공유)

---

## 📚 코드잇에서 진행한 실습 및 과제 비교

---

# 🍀 다음 스터디까지