# 2주차 정리

# 유닉스 커맨드 정리

# 1강

## 유닉스란?

- 1970년대 초반에 개발된 운영 체제
- 소프트웨어를 개발하고 실행할 수 있는 편리한 플랫폼
- 쉽게 수정해서 다른 컴퓨터에 적용할 수 있었다.
- 유닉스에서 파생된 다양한 언어들이 존재 한다. (유닉스 운영체제)
- 유닉스 커맨드란 유닉스 운영 체제에서 사용하는 커맨드이다.
- POSIX라는 유닉스의 표준이 있고 이 표준에 부합해서 공식적으로 인증을 받으면 Unix-certified, 만약 이 표준을 인증받지 않았지만, 사용하기에 기능적으로 거의 차이가 없는 정도라면 Unix-like라고 부른다.

## 리눅스란?

- 유닉스를 사용하거나 변형할 때 라이센스 비용을 지불해야 했다.
- '자유 소프트웨어 재단’이라는 곳에서, 유닉스의 코드를 하나도 사용하지 않고, 유닉스와 유사한 운영 체제를 직접 만들기 시작했고 이렇게 시작한 것이 GNU다.
- GNU라는 운영 체제는 이렇게 시작되었는데, 그중에 커널이라고 하는, 운영 체제의 핵심 부분이 잘 완성되지 않고 있었다.
- 이때 리누스 토발즈라는 학생이 커널 하나를 완성했고 리눅스(Linux)라는 이름으로 공개했다.
- GNU에 리눅스 커널을 합쳐서 만들었기 때문에, 이 운영 체제의 이름을 GNU/Linux라고 불렀다.

## 터미널이란?

- 인풋을 받고, 아웃풋을 출력해주는 프로그램을 뜻한다.

## shell이란?

- shell은 커맨드를 해석해주는 프로그램이다.
- 즉, 커맨드들을 컴퓨터가 이해할 수 있는 형태로 바꿔준다.
- shell 종류 중 하나가 bash(Bourne again shell)다. 가장 보편적이고, 많은 유닉스 운영 체제에서 기본 shell로 사용된다.

## 터미널 사용해보기

- argument : 커맨드의 대상 ex. 월 / 년도
- option : 커맨드를 어떻게 실행할지 정한다. ex. -j, -y

### 🌟 date

현재 날짜와 시간 출력

### 🌟 cal (월) (년도)

캘린더 출력, 월과 년도는 선택사항

### 🌟 cal -j (월) (년도)

그해에서 몇번째 날인지 출력해준다.

### 🌟 cal -y (년도)

해의 달력을 출력해준다.

### 🌟 cal -yj (년도)

해의 달력을 몇 번째 날인지 출력해준다.

## man 설명

### 1. NAME

- 커맨드 이름과 커맨드의 역할을 쓴다.

### 2. SYNOPSIS

- 커맨드 문법, 쓸 수 있는 argument, option을 정리해준다.
- [  ] 는 필수가 아니고 선택적이다.
- - 가 붙으면 option이다.
- argument를 받는 option들도 있다.

### 3. DESCRIPTION

- 커맨드에 대한 일반적인 설명이 쓰여 있다.
- 하단에는 옵션에 대한 설명들이 적혀 있다.

## 커맨드 꿀팁

- 위쪽 방향키를 누르면 이전 실행 커맨드가 입력된다.
- Ctrl + A : 커서를 맨 왼쪽으로 이동
- Ctrl + E : 커서를 맨 오른쪽으로 이동
- Ctrl + C : 작업 취소, 실행 취소
- Alt + →, ← : 단어 단위 이동
- clear : 터미널 내용을 지운다. 이전 커맨드 히스토리는 남아 있다.
- tab : 지금 작성하는 커맨드나 아규먼트들을 자동 완성 해준다.

# 2강

## 파일과 디렉토리(=폴더)를 다루는 커맨드

### 유닉스 디렉토리 구조

- 거꾸로 된 나무 같다.
- 맨 위에 root 또는 최상위 디렉토리가 하나 있고 그 안에 여러 디렉토리와 파일이 있고 각 디렉토리 안에 여러 디렉토리와 파일이 있다.
- 안에 있는 디렉토리는 하위/자식 디렉토리라 하고 밖에 있는 디렉토리를 상위/부모 디렉토리라고 한다.
- 사용자의 개인 파일들은 home 디렉토리 안에 있고 컴퓨터에 일반적으로 필요한 파일들은 밖에 있다.

## 파일 경로

- root는 /로 쓴다.
- 디렉토리 안으로 들어갈 때 /를 쓴다.
- 현재 사용자의 홈 디렉토리는 ~로 표현할 수 있다.

## 파일 둘러보기

### 🌟 pwd (= print working directory)

현재 위치에 있는 디렉토리 경로가 출력된다.

### 🌟 cd (= change directory)

- 다른 디렉토리로 이동한다.
- cd 뒤에 argument가 없으면 홈으로 이동한다.
- cd - 는 이전 디렉토리로 이동한다.

### 🌟 ls

- 현재 디렉토리의 내용을 리스트해서 보여준다.
- 경로를 argument로 주면 경로에 해당하는 내용을 리스트해서 준다.

### 🌟 ls  -a

- 모든 파일과 디렉토리의 내용을 리스트해서 보여준다.
- .파일처럼 안 보이던 파일들도 보여준다.

### 🌟 ls  -l

파일에 대한 정보를 출력한다.

### 절대 경로

- 루트 디렉토리를 기준으로 어떤 파일이나 디렉토리의 고유한 경로를 표기하는 것
- 경로가 길어질수록 복잡하다
- 멀리 떨어진 위치로 움직일 때 유리하다

### 상대 경로

- 현재 자신이 위치해 있는 디렉토리 기준으로 경로를 나타내는 것
- 현재 디렉토리를 .으로 표시한다.
- 상위 디렉토리를 ..으로 표시한다.

 ++ 경로를 argument로 받는 모든 커맨드에 절대 경로, 상대 경로 둘 다 사용 가능하다

### 파일 디렉토리에 공백이 있을 경우

1. ‘ ‘ 사용
2. “ ” 사용
3. \ 사용

### root 디렉토리엔 무엇이 있을까?

- **`/bin`**
    - 커맨드 프로그램의 일부가 있다.
- **`/sbin`**
    - 관리자 전용 프로그램들이 있다.
- **`/etc`**
    - 컴퓨터 설정 파일들이 있다.
    - 각종 프로그램의 설정 파일, 관리자 권한 설정 파일 같은 것들이 있다.
- **`/home` 또는 `/Users`**
    - 이 디렉토리에는 사용자들의 홈 디렉토리가 있다.
- **`/usr`**
    - 사용자(user)에게 필요한 파일들을 저장하고 있다.
    - `/usr/bin`에는 컴퓨터가 필요하기보다는 사용자가 필요한 커맨드들이 있다.
    - `local`이라는 디렉토리에는 사용자가 직접 설치한 프로그램과 관련된 파일들이 있다.

## 디렉토리 만들기

### 🌟 mkdir ‘디렉토리 이름’ (경로 포함 / ~/test)

- 여러 개를 한 번에 만들 수 있다. ex. mkdir jul aug

## 파일 만들기

### 🌟 touch ‘파일 이름’ (경로 포함 / ~/test)

- touch는 파일의 마지막 접근 시간이나 수정시간을 업데이트 한다.
- 만약 파일이 없다면 새로 생성한다.
- 여러 개를 한 번에 만들 수 있다. ex. touch jul/finance.txt jul/performance.txt

## Vim 사용하기

- **`vim`**만 치면 새로운 파일 작성, 경로를 argument로 주면 파일 수정이다. (**`vim path/to/file`** )

### Vim의 4가지 사용 모드

1.  일반 모드(Normal Mode)
    - 커서 이동, 텍스트 붙여 넣기, 작업 취소
    - 처음 열면 실행되는 모드다.
    - **`esc`** 를 누르면 실행된다.
    - **`yy`**를 누르면 줄 단위 복사, **`dd`**를 누르면 줄 단위 잘라내기, **`p`**를 붙이면 다음 줄에 붙여 넣어 진다.
2.  입력 모드(Insert Mode)
    - 텍스트 입력
    - **`i`** 를 누르면 실행된다.
3. 비주얼 모드(Visual Mode)
    - 텍스트 블록 지정, 텍스트 복사
    - **`v`**(글자 단위 복사), **`V`**(줄 단위) 를 누르면 실행된다.
    - **`y`** 를 누르면 복사, **`p`** 를 누르면 커서 아래 줄에 붙여 넣기가 된다.
    - **`d`** 를 누르면 잘라내기가 되고 **`p`** 를 누르면 붙여 넣기가 된다.
4. 명령 모드(Command Mode)
    - 내용 저장, Vim 종료
    - **`:`** 를 누르면 실행된다.
    - **`w`**는 파일을 저장하고, **`q`**는 vim을 종료한다.
    - **`:w`** “파일 이름” 이 파일 이름으로 저장된다.

## 파일 내용 살펴보기

### 🌟 cat

파일의 내용을 한꺼번에 화면에 출력하는 명령어다.

### 🌟 less

파일의 내용을 페이지 단위로 화면에 출력하는 명령어다.

### 🌟 head / tail (-n ‘숫자’)

- 파일의 시작 부분이나 끝 부분을 확인할 때 명령어다.
- (-n ‘숫자’)를 붙이면 숫자만큼의 줄이 출력된다.

## 파일과 디렉토리 옮기기 & 이름 변경하기

### 🌟 mv ‘작업할 대상의 경로’ ‘이동할 목적지 또는 변경할 이름’

- 파일과 디렉토리 옮기고 이름을 변경하는 명령어다.
- 만약 두 번째 경로가 이미 존재하는 디렉토리일 경우 디렉토리 안으로 이동되고 아니면 이름이 변경된다.

## 파일과 디렉토리 복사 붙여넣기

### 🌟 cp (-r) ‘복사할 대상의 경로’ ‘복사할 위치’

- 파일과 디렉토리(-r 옵션)를 복사 붙여 넣기 하는 명령어다.
- 만약 두 번째 argument가 이미 존재하는 디렉토리일 경우 디렉토리 안으로 복사 되고 아니면 두 번째 argument의 이름을 가진 파일이나 디렉토리가 생성된다.

### mv/cp 커맨드 주의할 점

- 같은 이름의 파일이 목적지에 있을 경우 덮어쓴다.
- **`-i`**  옵션은 충돌 발생 시 사용자에게 어떻게 할 지를 물어본다.

## 파일과 디렉토리 삭제하기

### 🌟 rm (-r) ‘삭제할 파일 또는 디렉토리 경로’

- 파일과 디렉토리(-r 옵션) 삭제하는 명령어다.
- 지우고 싶은 파일이나 디렉토리 여러 개를 argument로 줄 수 있다.
- **`-i`**  옵션은 각 파일을 지우기 전에 확실히 지울지 물어본다.
- **`-f`**  옵션은 어떤 상황에서도 파일을 지울지 물어보지 않는다.

# 3강

## 외부 프로그램 설치하기 (Window)

- apt는 우분투에서 외부프로그램을 설치하고 관리하는데 사용하는 툴이다.
- `apt update` 를 프로그램을 설치하기 전 해줘야 하는데 이 커맨드는 apt로 설치할 수 있는 프로그램들에 대한 최신정보를 인터넷에서 가져와 컴퓨터에 저장해준다.
- `sudo`는 관리자 권한을 임시로 갖게 해준다.

### 🌟 sudo apt install ‘다운 받을 프로그램 이름’

외부 프로그램을 다운로드 한다.

### 🌟 sudo apt remove ‘제거 할 프로그램 이름’

외부 프로그램을 삭제 한다.

## 외부 프로그램 설치하기 (macOS)

- homebrew는 CLI 환경에서 편하게 외부 프로그램을 설치하고 관리할 수 있는 프로그램이다.

### 🌟 brew install ‘다운 받을 프로그램 이름’

외부 프로그램을 다운로드 한다.

### 🌟 brew uninstall ‘제거 할 프로그램 이름’

외부 프로그램을 삭제 한다.

## Sudo란?

- 잠시 관리자 권한을 획득할 수 있는 커맨드다.
- 즉, 일시적으로 일반 유저에게 관리자 권한을 부여하는 커맨드다.

### 🌟 sudo command

관리자 권한을 가지고 command가 실행 된다.

# 4강

## WSL로 윈도우에 있는 파일 접근하기

- WSL을 사용하면 듀얼 부팅이나 가상 머신을 사용하는 것보다 더 가볍게 리눅스 환경을 이용할 수 있다.
- 또 윈도우에 있는 파일에 쉽게 접근할 수 있다.

### 예시

- 윈도우 파일은 `/mnt/c` 경로에 있다. (`/mnt/c` 가 윈도우의 `C:` 드라이브다.)
- 사용자의 홈 디렉토리는 `C:` 드라이브의 `Users` 디렉토리 안에 있다. `Users` 뒤에 윈도우 사용자 이름을 붙이면 된다.

## **PowerShell이란?**

- 윈도우 전용 커맨드라인 툴 중 하나이다.
- 시스템 관리, 자동화, 개발 등 다양한 작업을 할 수 있고 기본 유닉스 커맨드도 지원한다.
- cmd보다 기능이 많고 cmd에서 할 수 있는 건 다 할 수 있다.
- PowerShell은 기본 유닉스 커맨드를 지원한다.
- PowerShell에서는 기본적으로 cmdlet이라고 하는 커맨드들을 사용한다. (하고 싶은 동작과 대상 사이에 - 를 넣는다.)

### 🌟 Update-Help

도움말을 업데이트 한다.

## **실제 유닉스 커맨드와 차이점**

1. **경로**
    
    윈도우에서는 경로를 표시할 때 `/` 대신 `\`(한국 키보드는 `₩`)를 사용한다.
    
2. **옵션**
    
    cmdlet 옵션은 한 글자가 아닌 전체 단어다. 
    

### 유닉스 환경과 PowerShell 환경에서 실행했을 때 차이가 있는 커맨드

- man
    - aliasing 하고 있는 cmdlet에 대한 도움말을 보여준다.
    - 더 자세한 정보를 보고 싶다면 `-Full` 옵션을 사용하면 된다.
- ls
    - 파일/폴더 이름뿐만이 아닌 다양한 정보가 나온다.
    - 유닉스의 `ls -al` 과 유사하다.
- touch
    - `touch`라는 alias는 없다.
    - `$null > filename` 과 같은 방법을 사용해야 한다.
- cat
    - 아규먼트를 하나만 받는다.
- mv / cp
    - 목적지에 똑같은 이름의 파일/폴더가 있으면 파일이 이미 존재한다는 오류가 난다.
    - 만약 파일을 덮어쓰고 싶다면 `-Force` 옵션을 사용하면 된다.
    - 폴더를 복사할 때는 `-Recurse` 옵션을 사용해야 한다.
- rm
    - 폴더를 삭제할 때는 `-Recurse` 옵션을 사용해야 한다.
    - `-Recurse` 안 주면 안에 있는 파일을 지울 것인지 물어본다.

# Java Script 정리

# JavaScript 기초

## Java Script란?

- 웹 개발 뿐만이 아니라 모바일 앱이나, pc전용 프로그램, VR과 AR 같은 3D 컨텐츠,  블록체인을 만드는 데도 활용된다.

## 세미콜론

- 문장을 구분한다.
- 자바스크립트는 한 줄에 한 문장씩 작성될 때 자동으로 세미콜론을 추가해주는 기능이 있다.

## 코멘트

- 중간에 메모를 할 수 있다.
- 어떤 의도로 코드가 작성되었는지 설명할 때
- 구현한 코드가 어떤 동작을 하는지 기록할 때 사용한다.
- //(한 줄 코멘트), /* */ (여러 줄 코멘트)

# 자료형(Data type)이란?

## 숫자형(Number)

### 정수(Integer)

- ex. 0, 1, -10 …

### 소수(Floating point)

- 3.14, -1.47 …

## 문자열(String)

- “ “, ‘ ‘을 사용한다.
- + 로 문자열을 더할 수 있다. “a” + “b”  →”ab”

## 불린(Boolean)

- 참(true)과 거짓(false)을 나타낸다.
- 주로 어떤 조건에 의한 결과값으로 사용된다.

# 추상화(Abstraction)란?

- 구체적인 정보들은 숨기고 꼭 필요한 핵심만 꺼내서 표현하는 방식이다.
- 즉, 복잡한 것들을 목적에 맞게 단순화하는 것이다.
- 목적은 명확하게 / 불필요한 것들은 숨기기 / 핵심만 드러내기

# 변수(variable)

- 값을 저장하기 위한 상자
- 변수명으로 무엇을 의미하는지 설명할 수 있다.

## 변수 선언하기

<aside>
🌟 let ‘변수명’;

</aside>

<aside>
🌟 let ‘변수명’ = ‘변수값’; (선언과 동시에 값 할당)

</aside>

## 변수 이름 가이드

### 꼭 지켜야 하는 규칙

1.  JavaScript 식별자는 '문자(`a`-`z`, `A`-`Z`)', '밑줄(`_`)' 혹은 '달러 기호(`$`)'로 시작해야 한다. 두 번째 글자부터는 숫자도 가능하다.
2. '대문자'와 '소문자'는 구별한다.
3. '예약어(JavaScript가 찜해놓은 단어)'는 사용하면 안 된다.

### 지키면 좋은 규칙

1. 의미 없는 이름은 좋지 않다.
2. 추상적인 이름은 좋지 않다.
3. 모든 변수 이름은 'camelCase'로 쓰는 것이 좋다.

# 함수(function)

- 함수는 간단한 명령들을 저장한다.
- `console.log()`도 함수다.

## 함수 선언하기

<aside>
🌟 function ‘함수 이름’(파라미터) { 명령; 명령; };

</aside>

## 함수 호출

<aside>
🌟 ‘함수 이름’();

</aside>

## 매개변수(Parameter)

- 함수를 호출할 때 소괄호 안에 들어가는 값이다.
- 함수 내에서 변수처럼 사용할 수 있다.
- 함수 내부에서 파라미터를 변수처럼 사용하면 함수 호출할 때 소괄호 내부의 값이 파라미터에 전달된다.
- `,` 파라미터를 구분하면 여러 개를 입력할 수 있다.

## return문

- 함수 내부에서 정해진 일을 수행한 후 다시 돌려준다.
- 함수를 호출한 자리에 리턴 값이 전달된다.

<aside>
🌟 return ‘리턴값’;

</aside>

# JavaScript 핵심 개념

## 숫자형 (Number)

- 사칙연산 (+, -, *,  /) 가능
- `%`는 나머지를 계산한다.
- `**` 은 제곱을 할 때 쓴다.
- 사칙연산의 우선순위 규칙을 따른다.

## 문자열 (String)

- `“ “`, `‘ ‘` 로 감싸면 문자열이다.
- 작은 따옴표로 열었으면 작은 따옴표로 큰 따옴표로 열었으면 큰 따옴표로 닫아야 한다.
- 만약 문자열을 감싸는 따옴표 말고도 문자열 내부에서 작은 따옴표나 큰 따옴표를 사용하면 에러가 날 수 있다.
- 가장 쉬운 해결 방법은 문자열 내부에서 작은 따옴표 사용 시 큰 따옴표로 감싸고 큰 따옴표 사용 시 작은 따옴표를 사용하는 것이다.
- 다른 방법으로는 `\` 를 중복되는 따옴표 앞에 써주면 문자열 안의 기호라고 이해한다. ex. `“He said \”I’m an Iron man\””`
- `` `` 을 따옴표 대신 써줘도 된다.
- 믄자열 덧셈은 문자열을 연결한다.

## 불 대수 (Boolean)

- 일상적인 논리를 수학적으로 표현한 것이다.
- 진리값(true, false)을 사용한다.
- 불 대수의 연산에는 AND, OR, NOT이 있다.
- 명제는 참, 거짓이 확실한 문장이다.

### 불 대수의 연산

- 1. AND
    - x와 y가 모두 참일 때만 참이 된다.
    - `&&` 로 나타낸다.
- 2. OR
    - x와 y 중 하나라도 참일 때 참이 된다.
    - `||` 로 나타낸다.
- 3. NOT
    - 참이면 거짓으로, 거짓이면 참으로 만들어준다.
    - 중첩이 가능하다.
    - `!` 로 나타낸다.

## null과 undefined

### null

- 의도적으로 값이 없다는 것을 표현할 때 사용하는 값이다.
- `변수 = null` 처럼 의도적으로 값이 없음을 표현할 때 사용한다.

### undefined

- 값이 없다는 것을 확인하는 값이다.
- 선언 후 값이 주어지지 않은 변수는 undefined 값을 갖는다.
- `변수 = undefined` 도 가능하나 null과 혼란을 일으킬 수 있기에 사용하지 않는 것을 추천한다.

## typeof

<aside>
🌟 typeof ‘값’

</aside>

- 값을 평가해 해당하는 자료형을 문자열로 돌려준다.
- typeof는 기본적으로 연산자보다 우선순위가 높다.
- `typeof ‘hello’ + ‘world’ → stringhello`
- `typeof 8 - 3 → string - 3이 되기에 NaN (Not a Number)이 출력된다.`
- 이런 경우 ()로 우선순위를 높여주면 된다.

## 연산자 우선 순위

- 하나의 연산식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 우선순위(precedence)에 따라 결정된다.
- 우선순위 숫자가 클수록 먼저 실행된다.
- 순위가 같으면 대부분은 왼쪽부터 시작해서 오른쪽으로 연산이 수행된다.
- 괄호 > 논리 NOT > typeof > 거듭제곱> 곱셈, 나눗셈 > 덧셈, 뺄셈 > 크기 비교 > 등호 비교 > 논리 AND > OR > 할당

## 형 변환 1️⃣

- 문자로 바꾸고 싶을 땐 String을 사용하면 된다.
- `Number(’2’) + Number(’6’) → 8`
- 숫자로 바꾸고 싶을 땐 Number를 사용하면 된다.
- `String(2) + String(6) → 26`
- 불린으로 바꾸고 싶을 땐 Boolean을 사용하면 된다.

### 주의 사항

- 문자 → 숫자로 변환 시 문자가 숫자 형태가 아니라면 NaN으로 뜨고 숫자형이라면 Number로 변환된다.
- 불린 → 숫자로 변환 시 true면 1, false면 0으로 변환된다.
- 숫자/ 문자 → 불린으로 변환 시 일반적으로 1로 변환되나 없거나 빈 느낌을 주면( ex. ’ ‘, 0, NaN = falsey 값 ) 0으로 변환된다.

## 형 변환 2️⃣

### 산술연산자

- 산술 연산자(+, -, …)들은 연산 되어지는 두 값을 모두 숫자로 바꿔서 계산한다.
- 하지만 `+`는 양쪽 중 하나가 문자열이면 나머지 하나도 문자열로 바꾸어 문자열 덧셈을 한다.
- NaN 값은 어떤 값이랑 연산을 해도 NaN이 출력된다.

### 관계 비교 연산자

- 관계 비교 연산자(<, ≤, …)들은 연산 되어지는 두 값을 모두 숫자로 바꿔서 계산한다.
- 두 값이 비교가 불가능한 경우 false가 출력된다. ex. NaN

### 같음 비교 연산자

- `===, !==` 일치, 불일치 연산자
- `==, !=` 동등, 부등 연산자
- 일치 비교는 형 변환이 일어나지 않지만 동등 비교는 숫자로 형 변환이 일어난다.

## 템플릿 문자열

- 템플릿은 일정한 틀, 형식이다.
- `` ${변수/ 연산식/함수 ...} `` 을 사용하면 `+` 없이 템플릿 문자열을 만들어 문자열을 만들 수 있다.

## 할당 연산자 **(assignment operators)**

- `=`는 오른쪽에 있는 피연산자를 왼쪽에 있는 피연산자에 할당한다는 의미이다.
- 할당 연산자의 오른쪽부터 계산 후 왼쪽 변수에 할당한다.

## 복합 할당 연산자 **(Compound assignment operators)**

- 할당 연산자와 결합해서, 자주 쓰이는 표현을 더 간략하게 쓸 수 있게 하는 연산자이다.
- `+=, -=, *=, %=`  …

## **증가(increment), 감소(decrement) 연산자**

- `++, --`

## return

- 함수의 실행을 중지한다.
- 함수의 결과값을 되돌려준다.
- return문이 없는 함수를 호출하면 undefined가 리턴된다.

## 옵셔널 파라미터

- 파라미터에서 미리 값을 할당해 놓아 만약 값을 전달하지 않으면 미리 할당해 놓은 파라미터가 할당된다.
- 옵셔널 파라미터는 순서가 밀릴 수 있기에 가장 뒤 쪽으로 선언해야 한다.

## 변수의 scope

- 블록문 내부에서만 사용할 수 있는 변수를 로컬 변수, 지역 변수라고 한다.
- 블록문 밖에서 선언한 변수는 전역 변수라고 하며, 블록문 내부에서도 사용할 수 있으며 코드 전체에서 사용 가능하다.

## 상수(Constant)

- 변하지 않고 일정한 값을 유지하는 값이다.
- 상수를 값을 재할당하려고 하면 오류가 난다.
- 선언할 때 값을 할당하지 않아도 재할당하려고 하면 오류가 난다.
- 이름에 들어가는 모든 알파벳을 대문자로 쓰고 두 단어 이상이면 `_`로 이어준다.

<aside>
🌟 const ‘상수명’ = ‘값’

</aside>

## if문

```jsx
if (조건부분) {
	동작부분
}
else {
	동작부분
}
```

- 조건 부분이 참이면 동작부분을 수행한다.
- else문은 if문 외의 경우일 경우 동작부분을 수행한다.

## else if문

```jsx
if (조건부분) {
	동작부분
}
else if (조건부분) {
	동작부분
}
else {
	동작부분
}
```

- 두 가지 이상의 옵션이 필요한 경우 사용한다.

## switch문

```jsx
switch (비교할_값) {
	case 조건값_1:
		동작부분;
		break;
	case 조건값_2:
		동작부분;
		break;
	default:
		동작부분;
}
```

- break는 switch문을 탈출한다.
- switch문은 break를 만나기 전까지 아래의 모든 동작들을 실행한다.
- default에는 비교할 값이 모든 조건값과 일치하지 않을 때 동작할 동작부분을 작성한다.
- switch문은 값들을 비교할 때 자료형을 엄격하게 구분하기에 if문으로 대체 시 반드시 `===`를 사용해 비교를 해야 한다.

## for 반복문

```jsx
for (초기화부분; 조건부분; 추가동작부분;) {
	동작부분
}
```

- 조건이 충족되면 동작 부분을 반복한다.
- 초기화 부분은 for문이 시작할 때 가장 먼저 한 번만 실행되는 부분이다. 주로 반복의 횟수를 저장할 변수를 생성하는데 활용한다.
- 조건 부분은 boolean으로 바꿔 true면 동작을 실행하는 부분이다. false가 될 때까지 반복한다.
- 추가 동작 부분은 조건 부분이 true일 때 동작을 반복하고 추가로 실행하는 부분이다.

### tip

- 추가 동작 부분은 꼭 채울 필요는 없다.
- 초기화 부분에서 생성한 변수는 for문 안에서의 로컬 변수가 된다.
- 따라서 반복문이 종료되고 나서 for문 밖에서 변수를 사용하려고 하면 오류가 발생한다.
- 초기화 부분도 꼭 채울 필요는 없다.
- 반복문 밖에 있는 글로벌 변수를 활용해도 아무런 문제없이 같은 결과를 출력한다.
- 단, 소괄호 안쪽 가장 첫 번째 세미콜론은 생략할 수 없다.

## while 반복문

```jsx
while (조건부분) {
	동작부분
}
```

- 조건 부분을 만족하지 않을 때까지 반복한다.
- while문과 for문은 대체 가능하다.
- 전역 변수를 조건문 내부에 사용하고, 반복문이 종료된 후에도 변수를 사용해야 할 때 사용하기 좋다.

## break와 continue

- break를 반복문에 사용하면 조건문에 상관없이 실행되는 도중 빠져나올 수 있다.
- continue는 동작 부분을 한 번 건너 뛰는 것이다.

# JavaScript와 데이터

## 객체 (Object)

```jsx
let objectName = {
	값 이름: 값,
	key: value,
	property name: property value,
	...
}
```

- 여러 가지 값을 한 번에 저장할 때 사용한다.
- key, value 한 쌍을 속성(property)라고 부른다.
- property name은 string이다.
- 객체의 property 값으로 무엇이든 가능하다.

### property name 주의 사항

1. 첫 글자는 반드시 문자, 밑줄(_), 달러 기호($) 중 하나로 시작해야 한다.
2. 띄어쓰기 금지다.
3. 하이픈(-) 금지다.
4. 위의 경우 ‘ ‘로 감싸줘야 한다.

### 객체에서 데이터 접근하기

1. 점 표기법

<aside>
🌟 objectName.propertyName

</aside>

- 가장 간단하고 많이 쓰이는 방법이다.
- 하지만 따옴표를 생략할 수 없는 propertyName에는 접근할 수 없다.
1. 대괄호 표기법

<aside>
🌟 objectName[’propertyName’]

</aside>

- propertyName을 유연하게 구성할 수 있다.
- propertyName을 문자열로 만들 수 있는 어떤 방법이든 사용 가능하다.

## 객체 다루기

- 존재 하지 않는 property에 새로운 값을 할당하면 새로운 property가 생성된다.
- preperty에 새로운 값을 할당하면 값이 변한다.

<aside>
🌟 objectName.propertyName = 새로운 값

</aside>

- preperty를 삭제한다.

<aside>
🌟 delete objectName.propertyName

</aside>

### 객체의 preperty 존재 여부 확인

<aside>
🌟 objectName.propertyName !== undefined

</aside>

<aside>
🌟 ‘propertyName’ in object

</aside>

- boolean 형태로 리턴 된다.

## 메소드(Method)

```jsx
let objectName = {
	'함수 이름': function(파라미터){
		함수 내용
		},
		...
}
```

- 연관성 있는 함수들을 하나로 묶을 때 사용한다.
- 어떤 객체의 고유한 동작으로써, 함수에 의미를 부여할 수 있다.
- 객체의 property 값으로 함수를 넣어주면 된다.
- 이런 함수를 객체의 메소드라고 한다.
- 대괄호 표기법 사용시 `objectName['함수 이름'] (파라미터)` 형태로 쓴다.

## for..in 반복문

```jsx
for (변수 in 객체) {
	동작부분
}
```

- 객체 안의 property를 가지고 반복적인 동작을 수행할 때 사용한다.
- 객체의 프로퍼티 네임이 변수에 할당되고 객체의 프로퍼티 개수만큼 반복 동작을 하게 된다.

### 주의 사항

- 프로퍼티 네임에는 숫자형(양수)을 작성해서 사용할 수도 있다.
- 다만 실제로 사용될 때는 문자열로 형 변환이 되어 사용된다.
- 객체는 정수형 프로퍼티 네임을 오름차순으로 먼저 정렬하고,나머지 프로퍼티들은 추가한 순서대로 정렬하는 특징이 있다.

## 내장 객체

- 자바스크립트가 미리 가지고 있는 객체이다.

### Date 객체

```jsx
let myDate = new Date();
let myDate = new Date(특정한 값/ 밀리 초 단위);
let myDate = new Date(문자열);
new Date(YYYY, MM, DD, hh, mm, ss, ms);
```

- 이 객체를 생성한 시각이 출력된다.
- 요일, 월, 일, 년도, 시간, 시간대 순
- 특정한 값을 넣으면 UTC 기준 1970.1.1 00:00을 기준으로 특정한 값의 밀리 초만큼 지난 객체가 만들어진다.
- 날짜로 해석 가능한 문자열 사용 가능하다.
- month는 0부터 시작한다.

```jsx
myDate.getTime()
```

- myDate 객체가 1970.1.1 00:00:00 부터 몇 밀리초 지났는지 알려준다.
- 이를 타임스탬프라고 부른다.

## 배열 (Array)

```jsx
let arrayName = [elements, ...]
```

- 배열 안의 값은 요소(elements)라고 부른다.
- 배열 내의 순서를 index라고 한다.
- 순서가 있는 값을 처리할 때 사용하기 좋다.
- 여러 값의 묶음에도 사용한다.
- 배열도 객체다.

### indexing (0부터 시작)

```jsx
배열이름[index]
```

## 배열 다루기

```jsx
배열이름.length
배열이름['length']
```

- 배열이 가지고 있는 요소의 총 개수를 알려준다.

```jsx
배열이름[index] = 배열 값
```

- 배열의 요소를 추가하거나 수정한다.
- 인덱스의 순서를 뛰어넘으며 추가하게 되면, undefined 값이 들어간 요소가 자동으로 추가된다.

## 배열 메소드

```jsx
배열이름.splice(index, 삭제할 개수, 값)
```

- 해당 인덱스의 요소를 삭제한다.
- splice에 요소를 하나만 주면 그 인덱스 뒤 모든 요소를 삭제한다.
- 세 번째 파라미터의 값은 삭제하고 이 값을 추가하겠다는 뜻이다.
- 삭제할 개수를 0으로 하면 삭제 없이 요소를 추가할 수 있다.
- 1이면 수정할 수 있다.

```jsx
배열이름.shift();
```

- 배열의 첫 요소를 삭제하고 나머지 요소들은 앞으로 밀어준다.

```jsx
배열이름.pop();
```

- 배열의 마지막 요소를 삭제한다.

```jsx
배열이름.unshift(value);
```

- 배열의 첫 요소로 값을 추가하고 나머지 요소들은 뒤로 밀어준다.

```jsx
배열이름.push(value);
```

- 배열의 끝 부분에 값을 추가한다.

```jsx
배열이름.indexOf(item);
배열이름.lastIndexOf(item);
```

- 배열에 `item`이 포함되어 있는지 확인할 수 있다.
- 만약 포함되어 있다면, `item`이 있는 인덱스가 리턴된다.
- 포함되어 있지 않다면, `-1`이 리턴된다.
- 여러 번 포함되어 있으면, 처음 발견된 인덱스가 리턴된다.
- `lastIndexOf` 는 탐색을 뒤에서 부터 한다.

```jsx
배열이름.includes(item);
```

- 배열에 `item`이 있을 경우 `true`를, 없을 경우 `false`를 리턴한다.

```jsx
배열이름.reverse();
```

- 배열의 순서를 뒤집는다.

## for..of 반복문

```jsx
for (변수 of 배열) {
	동작부분
}
```

- 변수에 배열의 요소가 할당 된다.

## 다차원 배열 (multidimensional array)

```jsx
배열이름 = [[값, 값], [값, 값]...]
배열이름.[index][index]
```

## 숫자 표기법

```jsx
let number = 1000000000;
let number = 1e9;
```

- 알파벳 e를 사용하여 표기하는 방식을 지수 표기법이라고 한다.
- 알파벳 왼쪽에 있는 수에 오른쪽 수만큼 10의 거듭제곱을 곱하는 의미가 담겨 있다.

```jsx
hex -> 16진법 (0x)
octal -> 8진법 (0o)
binary -> 2진법 (0b)
```

## 숫자형 메소드

```jsx
변수.toFixed(값)
정수..toFixed(값)
(정수).toFixed(값)
```

- 값만큼 소숫점 아래 자릿수를 고정해준다.
- 범위는 100까지 이다.
- 반올림 / 부족하면 0으로 채운다.
- 계산 값이 문자열이다.

```jsx
변수.toString(진법)
```

- 파라미터로 전달하는 숫자의 진법으로 계산해준다.
- 범위는 2 ~ 36이다.
- 계산 값이 문자열이다.

## **Math객체**

### 절대값

```jsx
Math.abs(값)
```

### **최댓값 (Maximum)**

```jsx
Math.max(값, 값, 값, 값, 값, ...)
```

- 이 중 가장 큰 값이 리턴된다.

### **최솟값 (Minimum)**

```jsx
Math.min(값, 값, 값, 값, 값, ...)
```

- 이 중 가장 작은 값이 리턴된다.

### 거듭제곱 **(Exponentiation)**

```jsx
Math.pow(값, 값)
```

## **제곱근 (Square Root)**

```jsx
Math.sqrt(값)
```

## **반올림 (Round)**

```jsx
Math.round(값, 값)
```

## **버림과 올림 (Floor and Ceil)**

```jsx
Math.floor(값) - 버림
Math.ceil(값)  - 올림
```

## **난수 (Random)**

```jsx
Math.random()
```

- 0 이상 1 미만의 값이 랜덤으로 리턴된다.

## 문자열 심화

```jsx
//문자열 길이
String 변수 이름.length
```

```jsx
//요소 접근
String 변수 이름.charAt(index)
String 변수 이름[index]
```

```jsx
//요소 탐색
String 변수 이름.indexOf(탐색할 요소)
String 변수 이름.lastIndexOf(탐색할 요소)
// 문자열에 없는 문자를 찾으면 -1이 출력된다.
```

```jsx
//대소문자 변환
String 변수 이름.toUpperCase()
String 변수 이름.toLowerCase()
```

```jsx
//양 끝 공백 제거 
String 변수 이름.trim()
```

```jsx
//부분 문자열 접근
String 변수 이름.slice(start, end)
//start부터 end - 1까지
```

## 기본형 (Primitive type)

- 객체를 제외한 다른 자료형들이다.
- 변수 이름을 가진 상자에 기본형 값을 넣어준다고 생각할 수 있다.

## 참조형 (Reference type)

- 어딘가에서 객체가 만들어지고 변수에는 객체값으로 가는 주소가 저장된다.
- 즉, 변수 == 주소값이다.
- 주소가 복사된다.

### 참조형 복사하기

```jsx
배열이름.slice() //원래 값 그대로 리턴
Object.assign({}, 객체 이름) //객체 복사
for (let key in 객체 이름) {
	빈 객체[key] = 복사할 객체[key];
}
```

## const

- const로 할당한 변수는 재할당 되지 않는다.
- 코드에 변수여도 변하지 않는 것들이 있다.
- 코드를 일관되고 안전하게 유지하기 위해 사용한다.
- 객체는 변수의 주소값이 저장되기에 const로 선언해도 변할 수 있다.

## var

- `let` 이나 `const` 처럼 똑같이 키워드 다음에 변수이름을 써서 선언할 수 있고, 키워드와 변수이름, 그리고 할당연산자와 값으로 선언과 동시에 값을 할당해 줄 수도 있다.

```
var 변수명;
변수명 = 변수값;
```

- 중복 선언이 가능하다. 기존의 변수를 덮어써 버린다.
- `var` 키워드로 선언한 변수는 scope가 `function`에서만 구분되어 있다.
- `var` 변수는 함수 스코프를 기준으로 선언되기 이전에도 변수에 접근이 가능하다.