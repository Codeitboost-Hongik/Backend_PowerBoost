# 1주차 정리

# Git 정리

# 1장

# GIT이란?

- 코드 버전 관리와 동시 협업을 할 수 있는 프로그램이다.
- 버전 관리란 파일의 변화를 시간에 따라 기록했다 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템을 말한다.
- Git은 매번 작성했던 버전을 하나의 버전으로 저장할 수 있게 해준다.
- Git은 여러 개발자들이 협업 할 수 있게 해주는 기능도 있다. Git을 이용하면 여러 개발자가 동시에 작성한 코드를 합칠 수 있다.

## Git의 장점

1. 지난 과정을 확인 할 수 있다.
2. 잘못된 부분이 생기면 이전 버전으로 돌아갈 수 있다.

# Git의 역사

- 리누스 토발즈라는 사람이 만들었다.
- 리누스 토발즈는 리눅스를 만든 사람으로 리눅스를 만든 이후 BitKeeper라고 하는 툴로 리눅스의 각 버전들을 관리하고 있었다. 그런데 어떤 일을 계기로 사이가 틀어지게 되었고 BitKeeper를 대신할 다른 버전관리 시스템을 찾아보게 되었다. 하지만 맘에 드는 버전관리 툴을 찾지 못했고 Git을 직접 만들게 되었다.
- Git은 당시에 빠른 속도, 단순한 디자인, 비선형적 개발 지원, 완전 분산형 시스템, 리눅스와 같은 거대한 프로젝트도 속도 저하의 문제없이 관리할 수 있는 시스템이라는 목표를 갖고 설계 제작되었다.

# GitHub란?

- 원격저장소를 대신 제공해주는 서비스다.
- GitHub는 외부 컴퓨터를 따로 마련하지 않아도 작업물을 본인의 컴퓨터가 아닌 다른 곳에 저장할 수 있게 한다.
- GitHub는 Git으로 만든 작업물을 올려놓을 수 있는 사이트이다.
- 다른 사람과의 협업이 가능해졌다.

- 추가
    
    Git은 다른 컴퓨터에 작업물을 보낼수도 있다. 
    
    외부 컴퓨터에 작업물을 보낸다는 건 백업본을 만들 수 있다는 것이다. 
    
    다른 컴퓨터에 작업물을 보내는 것의 또 다른 장점은 다른 사람과의 협업이 가능해진다는 것이다. 
    
- 

# 2장

# Git의 repository(저장소)

- 우리가 어떤 프로젝트를 할 때 프로젝트에 필요한 것을 담는 프로젝트 디렉토리를 만든다.
- 이때 Git으로 프로젝트 디렉토리 버전을 관리하기 시작하면 원하는 시점마다 디렉토리에 무엇이 있는지 내용이 어떻게 변해가는지 관리할 수 있다.
- .git 디렉토리가 레포지토리다!

# Git의 commit

- 프로젝트 디렉토리의 특정 모습을 하나의 버전으로 남기는 것이다.
- 커밋하면 커밋하는 당시의 프로젝트 디렉토리의 모습이 사진처럼 레포지토리에 저장된다.
- 고정된 결과물 자체도 커밋이라고 한다.
- 커밋을 하기 전에 Git에게 커밋하는 사람이 누구인지 알려줘야 한다.
- 커밋하기 전에는 커밋할 파일들을 미리 지정해 줘야 한다. (add 커맨드)

## commit 주의 사항

1. 처음으로 커밋을 하기 전 사용자의 이름과 이메일 주소를 설정해야 한다.
2. 커밋 메시지 남기기
3. 커밋 하기 전 커밋할 파일을 git add로 지정해줘야 한다.

- 🌟git init
    
    현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리 생성
    

- 🌟git config [user.name](http://user.name/) “아이디”
    
     사용자의 아이디를 “아이디”로 설정
    

- 🌟git config [user](http://user.name/).email “이메일”
    
     사용자의 이메일를 “이메일”로 설정
    

- 🌟git commit –m “커밋 메세지”
    
     커밋할 때 메모를 남기는 것으로 어떤 변화가 있었는지 알려준다.
    

- 🌟git add “파일” / .
    
     파일을 커밋한다고 지정하는 것
    
    ++ “파일” 대신 .을 쓰면 변경사항이 생긴 모든 파일들이 모두 지정된다.
    

- 🌟git status
    
     Git이 인식하고 있는 프로젝트 디렉토리의 현재 상태를 보여줌
    

- 🌟git reset “파일”
    
     staging area에서 파일 제거
    
    하지만 변경된 내용은 working directory애 그대로 남아있다!
    

- 🌟git help “커맨드”
    
     사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력
    

# Git의 3가지 작업 영역

### 1. working directory (= working tree)

- working directory는 작업을 하는 프로젝트 디렉토리를 말한다.

### 2. staging area (= index)

- git add를 한 파일들이 존재하는 영역이다.
- 커밋을 하면 staging area에 있는 파일들만 커밋에 반영된다.
- 이 단계를 통해 선별적인 커밋 가능

### 3. repository

- working directory의 변경 이력들이 저장되어 있는 영역이다.

<aside>
💡 즉, 1번에서 작업하고 git add로 2번에 가게 되고 커밋을 하면 2번에 있던 파일들이 스냅샷처럼 3번에 저장된다!

</aside>

# Git의 4가지 파일 상태

### Untracked

파일이 Git에  의해서 변동 사항이 추적 되지 않고 있는 상태

### Tracked

파일이 Git에  의해서 변동 사항이 추적 되고 있는 상태

- Staged
    
    파일의 내용이 수정된 후 staging area에 올라와 있는 상태
    
- Unmodified
    
    현재 파일의 내용이 최신 커밋의 모습과 비교했을 때 전혀 바뀐 게 없는 상태
    
- Modified
    
    현재 파일의 내용이 최신 커밋의 모습과 비교했을 때 조금이라도 바뀐 게 있는 상태
    

# 3장

# GitHub에 관해서…

작업하던 내용을 전송한다는 건 레포지토리를 전송하는 것이다. 레포지토리에는 프로젝트 디렉토리의 모든 변경이력이 있다. 이걸 외부 컴퓨터에 전송하면 외부 컴퓨터에서 내 컴퓨터처럼 작업 가능하고 버전관리도 가능하다. 

 ⇒ GitHub가 이런 기능을 제공한다.

### git push/ pull

- 로컬 레포지토리의 내용을 리모트 레포지토리에 보내고 로컬 레포지토리에 새로운 커밋을 하면 리모트 레포지토리에 반영되지 않는다.
- 만약 새로운 커밋을 리모트 레포지토리에도 반영하고 싶다면 새로운 작업을 해야하는데 이는 git push다.
- 리모트 레포지토리의 새로운 커밋을 로컬 레포지토리에 반영하려면 git pull을 사용하면 된다.
- git push는 원래 리모트 레포지토리의 주인만 할 수 있다. 다른 사람도 할 수 있게 하려면 그 사람을 collaborator로 초대하면 된다.

### 🌟 git push

로컬 레포지토리 내용을 그대로 리모트 레포지토리에 반영한다.

### 🌟 git pull

리모트 레포지토리의 새로운 내용을 가져와서 로컬 레포지토리에 반영한다.

### 로컬 레포지토리와 똑같은 내용의 리모트 레포지토리를 만드는 이유?

1. 안전성(복원/백업)
2. 다른 개발자들과 협업 가능
    - 각각의 개발자가 리모트 레포지토리의 내용을 가져와 새로운 커밋을 하고 리모트 레포지토리에 push를 하는 식으로 협업이 가능하다.

# 오픈 소스 프로젝트

- 소스 코드가 공개되어 있는 프로젝트
- ‘오픈 소스’란 프로그램의 소스 코드가 대중에 공개된 상태를 뜻한다.
- 오픈 소스라고 해서 아무런 제약이 없는 것은 아니다. (오픈 소스에도 다양한 종류의 라이센스가 있기 때문이다.)

### 🌟 git clone “주소”

깃허브 프로젝트의 레포지토리를 그대로 복제한다. 

# README.md

- 프로젝트에 대한 설명과 주요 사용법, 실행시키기 위해 어떤 사전 작업이 필요한지 알려주는 내용이 적혀 있다.
- .md는 markdown의 줄임말로 이 파일에 마크다운으로 내용을 작성할 수 있다.

# 4장

# commit history

- 커밋 히스토리란 이때까지 한 커밋들을 말한다.
- 커밋 아이디( = 커밋 해시)로 각 커밋을 구별해 관리한다.

### 🌟 git log

커밋 히스토리를 출력한다.

### 🌟 git log —pretty=oneline

커밋 히스토리를 한 줄로 깔끔하게 보여준다.

### 🌟 git show “커밋 아이디”

커밋할 때 이전과의 차이를 출력한다.

### 🌟 git commit —amend

최신 커밋을 수정할 수 있다.

### commit은 -m 커맨더를 쓰지 않고도 커밋 메세지를 쓸 수 있다!

- git commit만 치면 창이 뜬다. 거기에 커밋 메세지를 입력하면 된다.

# commit에 관해서…

- 커밋은 staging area의 현 상태를 그대로 하나의 버전으로 남기는 작업, 또는 그 결과물을 가리키는 말이다.
- 커밋에는 크게 3가지 정보가 있다.
    1. 커밋을 한 사용자 아이디
    2. 커밋한 날짜, 시간
    3. 커밋 메시지

### 커밋 메시지 가이드라인

1. 커밋 메시지의 제목과 상세 설명 사이에는 한 줄을 비워둔다.
2. 커밋 메시지의 제목 뒤에 온점 붙이지 말기
3. 커밋 메시지 제목의 첫 번째 알파벳은 대문자다.
4. 커밋 메시지의 제목은 명령조로 작성한다.
5. 커밋의 상세 내용에는 왜 커밋을 했는지/ 어떤 문제가 있었고 적용한 해결책이 어떤 효과를 가지는지 적어두면 좋다.
6. 최대한 친절하게 작성한다.

### 커밋할 때 알아야 할 가이드라인

1. 하나의 커밋에는 하나의 수정 사항, 하나의 이슈를 해결한 내용만 남긴다.
2. 현재 프로젝트 디렉토리의 상태가 그 내부의 전체 코드를 실행했을 때 에러가 발생하지 않는 상태인 경우에만 커밋을 해야 한다.

# 커맨드에 alias 설정하기

- Git에는 길이가 긴 경우의 커맨드 전체에 별명을 붙여서 그 별명을 사용할 수 있도록 해주는 기능이 있다.
- 붙이는 별명을 **alias**라고 하고, 별명을 붙이는 행위를 **aliasing**이라고 한다.

### 🌟 git config alias.”별명” “커맨드”

길이가 긴 커맨드에 별명을 붙여서 이후로는 별명으로도 해당 커맨드를 실행할 수 있게 설정한다.

# 두 커밋 간의 차이 보기

### 🌟 git diff “이전 커밋 아이디” “이후 커밋 아이디”

두 커밋 간의 차이 비교한다.

# HEAD란?

- 보통 가장 최근에 한 커밋을 가리킨다.
- 매번 더 새로운 커밋을 가리킨다.
- working directory는 HEAD 가 가리키는 커밋에 따라 구성된다. 즉, HEAD 가 가리키는 commit에 따라 working directory는 그걸 따라 변한다.

# git reset에 대하여…

- 헤드가 과거의 커밋을 가리키게 할 수 있다.
- working directory의 내용도 과거 커밋 모습으로 돌아가게 한다.
- 과거 커밋으로 아예 돌아가고 싶을때 사용한다.

## git reset의 3가지 옵션

### 1.  soft

<aside>
🌟 git reset —soft “커밋 아이디”

</aside>

- HEAD가 특정 커밋을 가리키도록 이동시킨다.
- staging area와 working directory는 그대로이다.

### 2.  mixed

<aside>
🌟 git reset —mixed “커밋 아이디”

</aside>

- HEAD가 특정 커밋을 가리키도록 이동시킨다.
- staging area도 특정 커밋처럼 리셋된다.
- working directory는 그대로이다.

### 3.  hard

<aside>
🌟 git reset —hard “커밋 아이디”

</aside>

- HEAD가 특정 커밋을 가리키도록 이동시킨다.
- staging area도 특정 커밋처럼 리셋된다.
- working directory도 특정 커밋처럼 리셋된다.

## HEAD를 기준으로 reset 하기

### 🌟 git reset --hard HEAD^

이전 커밋으로 reset 된다.

### 🌟 git reset --hard HEAD~2

HEAD가 가리키는 커밋보다 2단계 이전 커밋으로 reset 된다.

# Tag

- 프로젝트에서 주요 버전의 시작점이 되는 커밋에 태그를 단다.

### 🌟 git tag “태그 이름”  “ 커밋 아이디”

특정 커밋에 태그를 붙인다.

### 🌟 git tag

모든 태그를 출력한다.

### 🌟 git show “태그 이름”

태그와 연결된 커밋을 출력한다.

# 5장

# Branch란?

- branch는 하나의 코드 관리 흐름이다.
- branch는 어떤 커밋을 가리키는 존재다.(포인터)
- main branch는 레포지토리를 만들고 커밋을 하면 자동으로 생기는 브랜치이다. (기본 브랜치)

### 🌟 git branch “브랜치 이름”

브랜치 만든다.

### 🌟 git checkout “브랜치 이름”

해당 브랜치로 이동한다.

### 🌟 git branch

브랜치 목록을 출력한다.

### 🌟 git branch –d “브랜치 이름”

브랜치를 삭제한다.

### 🌟 git checkout –b “브랜치 이름”

브랜치를 만들고 바로 해당 브랜치로 이동한다.

# Branch merge하기

- merge는 헤드가 가리키던 커밋에 다른 브랜치가 가리키던 커밋을 합쳐서 새로운 커밋을 만드는 작업이다.
- merge를 통해서 생겨난 커밋을 merge commit이라 한다.

### 🌟 git merge “브랜치 이름”

현재 브랜치에  “브랜치 이름” 브랜치를 합친다.

## Conflict

- merge할 때 conflict가 발생할 수 있다.

### 해결 방안

1. conflict가 발생한 파일을 연다
2. merge의 결과가 되었으면 하는 모습대로 코드를 수정한다.
3. 커밋하기

또는 merge 자체를 취소해도 된다.

### 🌟 git merge --abort

머지 작업을 취소한다.

### 파일 여러개가 conflict

1. 파일 하나씩 conflict를 해결하고 git add “파일 이름” 커맨드로 하나씩 staging area에 올리거나(중간중간에 git status 커맨드로 현재 상태 확인하면서)
2. 모든 파일들의 conflict를 다 해결하고, git add . 커맨드로 한번에 staging area에 올리고
3. 커밋한다.

# 리모트 레포지토리에 대한 추가 설명

### 🌟 **git remote add origin “깃 주소”**

- “깃 주소” 리모트 레포지토리를 **origin**이라는 이름으로 등록하겠다는 뜻이다.
- origin 대신 다른 단어를 쓸 수 있으나 origin을 쓰는 것이 관습이다.

### 🌟 **git push -u origin master**

- 현재 로컬 레포지토리에 있는 main 브랜치의 내용을 origin이라는 리모트 레포지토리로 보낸다는 뜻이다.
- 이때 같은 이름의 브랜치로 전송하게 되는데 만약 origin이라는 리모트 레포지토리에 main 브랜치가 없으면 브랜치를 새로 생성하고 푸시합니다.
- 이때 -u는 --set-upstream이라는 옵션의 약자로 사용하면 로컬 레포지토리에 있는 master 브랜치가 origin에 있는 main 브랜치를 tracking하는 걸로 설정된다.
- tracking connection이 한번 설정되고 나면, 자동으로 git pull, push등이 작동한다.

# HEAD 추가 내용

- 사실 브랜치는 커밋을 가리키는 존재(포인터)이고, HEAD는 이런 브랜치를 통해 커밋을 간접적으로 가리키는 존재(포인터)이다.
- 즉, 헤드는 커밋을 직접적으로 가리키는 게 아니라 브랜치를 가리킨다.

# git reset과 checkout

## reset 주의 사항

- 과거의 커밋으로 git reset을 한다고 그 이후의 커밋이 사라지는 건 아니다.
- 현재 HEAD가 가리키고 있는 커밋 이후의 커밋으로도 리셋할 수 있다.

## git reset과 checkout 차이

- checkout은  HEAD가 직접적으로 가리키는 것을 바꿀 수 있는데 헤드가 직접 커밋을 가리키도록 할 수 있다. 이게 바로 Detached HEAD다.
- 위의 경우는 브랜치의 특정 시점으로 돌아가서 새로운 브랜치를 만들 때 주로 사용 된다.

reset

checkout

- 헤드가 가리키던 브랜치가 다른 커밋을 가리키기도 한다.

- 헤드 자체가 커밋이나 브랜치를 가리키도록 한다.
- 헤드도 결국 간접적으로 다른 커밋을 가리키게 된다.

# 6장

# Git 실무 지식 1️⃣

## **git push 전에 보통 git pull을 해야하는 이유**

- 내가 로컬 레포지토리에서 수정하고 커밋하려고 할 때 리모트 레포지토리에 변화가 있다면 git push는 실패한다. 이 경우 git pull을 먼저 해 merge한다.
- 이때 conflict가 발생할 수도 있는데 전에 배운 내용처럼 해결 후 다시 push하면 된다.
- 리모트 레포지토리에 있는 커밋이 로컬 레포지토리보다 한 단계 앞서 있을 때는 어차피 git pull을 해야만 git push를 할 수 있다.
- 여러 개발자가 협업을 할 때는 리모트 레포지토리가 가장 중심이자 우선이 된다.

## Fetch

- git pull은 리모트 레포지토리에 있는 브랜치를 가져 와 현재 브랜치에 자동으로 머지한다.
- git fetch는 리모트 레포지토리에 있는 브랜치를  머지는 하지 않고 가져오기만 한다.
- fetch는 브랜치 레포지토리에 있는 브랜치의 내용을 일단 가져와서 살펴본 후에 머지하고 싶을 때 사용한다.
- 이후 git diff로 차이점을 보고 해결한다.
- (브랜치를 가져온다는 것은 브랜치가 가리키고 있는 커밋 이전에 이루어진 모든 커밋들을 가져온다는 것이다.)

### 🌟 git fetch

로컬 레포지토리에서 현재 HEAD가 가리키는 브랜치의 업스트림(upstream) 브랜치로부터 최신 커밋들을 가져온다.

## 코드 작성자 찾기

- git blame은 어떤 파일의 특정 코드를 누가 작성했는지 찾아내기 위한 커맨드다.

### 🌟 git blame

어떤 파일의 특정 코드를 누가 작성했는지 찾아내기 위한 커맨드이다.

특정 파일의 내용이 어떤 커밋에 의해 생긴 것인지 출력한다.

## 커밋 취소하기

- git revert를 이용해 커밋에서 이루어진 작업을 취소할 수 있다.

### 🌟 git revert “커밋 아이디”

특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성한다.

### 🌟 git revert “시작 전 줄 커밋 아이디”..”지우고 싶은 마지막 커밋 아이디”

위와 같으나 여러 커밋을 취소할 수 있다.

첫번째 커밋 아이디는 지워지지 않는다.

### 왜 reset이 아닌 revert를 쓸까?

- reset는 HEAD가 간접적으로 가리키던 커밋이 바로 직전 커밋으로 이동하게 된다.
- 이때 리모트 레포지토리에 더 최신 커밋이 있기에 이 상태에서는 git push를 할 수 없다.
- revert는 특정 커밋에서 이루어진 작업을 되돌리는(취소하는) 커밋을 새로 생성하기 때문에 최신 커밋이 생기는 것이다.
- 따라서 revert를 쓰면 git push를 할 수 있다.
- 하지만 전 커밋과 새로운 커밋이 똑같기 때문에 낭비다. 따라서 커밋은 신중하게 해야 한다.

# 7장

# Git 실무 지식 2️⃣

## git reset 후 돌아오기

- git reset을 해도 그 이후의 커밋들이 사라지는 것은 아니다.
- 만약 이후의 커밋의 아이디를 안다면 git reset 명령어로 다시 돌아올 수 있다.
- 만약 이후의 커밋 아이디를 모른다면 git reflog로 커밋 아이디를 확인 할 수 있다.
- reflog란 reference log의 줄임말로 헤드가 이때까지 가리켜왔던 커밋들을 기록한 정보를 출력한다.

### 🌟 git reflog

헤드가 이때까지 가리켜왔던 커밋들을 기록한 정보를 출력한다.

## 커밋 히스토리 보는 다른 방법

### 🌟 git log —pretty=oneline --all

모든 브랜치의 커밋들을 보여준다.

### 🌟 git log —pretty=oneline --all --graph

커밋 히스토리가 각 브랜치와의 관계가 잘 드러나도록 그래프 형식으로 출력된다.

## Rebase (커밋 재배치)

- 커밋을 재배치한다.
- 머지와 거의 동일하다.
- 리베이스나 머지나 결과물은 같다.
- 하지만 머지는 머지 커밋이 생기지만 리베이스는 같은 선 상으로 옮겨가는 것이다.

### 🌟 git rebase “브랜치”

커밋을 재배치한다.

### 🌟 git rebase continue

git rebase로 conflict 발생 시 해결하고 커밋 대신 사용한다.

컴플릭트가 발생해서 제대로 진행되지 못한 리베이스를 계속 진행하라는 뜻이다.

### 머지와 리베이스 차이

1. 리베이스는 새로운 커밋을 만들지 않는다.
2. 리베이스로 만들어진 커밋 히스토리는 머지로 만들어진 커밋 히스토리보다 좀 더 깔끔하다.

<aside>
💡 즉, 두 브랜치를 합쳤다는 정보가 커밋 히스토리에 꼭 남아야하는 경우라면 커밋을, 커밋 히스토리를 깔끔하게 유지하는 게 중요한 경우 리베이스를 쓴다.

</aside>

## 작업 내용 임시 저장하기

- 어떤 브랜치에서 하던 작업을 아직 커밋 하지 않았는데 다른 브랜치로 가야하는 상황에 작업 내용을 잠깐저장하고 싶을때 git stash를 사용한다.
- git stash를 사용하면 working directory에서 작업하던 내용을 Git이 stack에 보관해준다.
- 즉, 최근 커밋 이후로 작업했던 내용은 모두 스택에 옮겨지고 working directory 내부는 다시 최근 커밋 상태로 초기화된다.
- 

### 🌟 git stash

현재 작업 내용을 스택 영역에 저장한다.

### 🌟 git stash list

stash한 내역을 보여준다.

### 🌟 git stash apply “커밋 아이디”

스택에 있는 내용을 다시 working directory로 가져와서 적용한다.

### 🌟 git stash drop “커밋 아이디”

스택 내용을 삭제한다.

### 🌟 git stash pop “커밋 아이디”

특정 작업 내용을 적용함과 동시에 그것을 스택에서 제거한다.

### 잘못된 브랜치에서 작업한 경우?

- 이때도 git stash를 사용한다.
    1.  git stash로 스택에 작업 내용을 저장한다.
    2. 올바른 브랜치로 가서 다시 git stash apply를 한다.
    

## 필요한 커밋만 가져오기

### 🌟 git cherry-pick “커밋 아이디”

자신이 원하는 작업이 들어있는 커밋들만 가져와서 현재 브랜치에 추가한다.

## 여러 커밋을 하나의 커밋으로 만들기

- git reset의 3가지 옵션 중 soft와 mixed는 working directory의 내용이 변하지 않는다.
- 따라서 reset 사용 후 다 시 커밋을 하면 이전의 커밋들이 하나의 커밋이 된다.

## git이 무시하는 파일들

- working directory 안에 있음에도 불구하고 Git에 의해 그 존재 자체가 무시되는 파일들이다.
- 버전 관리를 할 정도의 가치가 없고, 오히려 버전 관리를 하면 용량만 더 차지하고, 나중에 각 버전을 살펴볼 때 가독성을 떨어뜨리기만 하기 때문에 Git이 무시하도록 설정했다.

### **.gitignore 파일이란?**

- working directory 내에 존재하는 파일들 중에서 마치 존재하지 않는 것처럼 Git이 인식 해야 할 파일들의 목록이 적힌 파일이다.